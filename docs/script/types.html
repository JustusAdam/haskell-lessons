<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Types &#8212; Haskell Lessons 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="types">
<span id="id1"></span><h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-defined-types">
<span id="id2"></span><h2>User defined types<a class="headerlink" href="#user-defined-types" title="Permalink to this headline">¶</a></h2>
<p>Defining types in Haskell takes three forms.</p>
<div class="section" id="aliases">
<span id="type-alases"></span><h3>Aliases<a class="headerlink" href="#aliases" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">type</span></code> keyword allows us to define a new name for an existing type.
This can have two different purposes:</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>It allows us to define shorter names for long type.</dt>
<dd><p class="first">For instance</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MakerM</span> <span class="n">a</span> <span class="o">=</span> <span class="n">StateT</span> <span class="p">(</span><span class="n">ALongStateName</span> <span class="n">String</span> <span class="n">Bool</span> <span class="p">(</span><span class="n">HashMap</span> <span class="n">Text</span> <span class="n">Int</span><span class="p">))</span> <span class="p">(</span><span class="n">LoggingT</span> <span class="n">IO</span><span class="p">)</span> <span class="n">a</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>We can abstract our API from the concrete type.</dt>
<dd><p class="first">If our program uses a Map like structure for instance, but we are not sure yet that we want to stick with a concrete Map type we might write the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>type MyMap key value = HashMap key value
-- or (omitting the `value` variable)
type MyMap key = HashMap key
-- or (omitting both the `value` and `key` variable)
type MyMap = HashMap
</pre></div>
</div>
<p>We can then later replace it with a different map type if we like and we do not need to change all of our type signatures.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MyMap</span> <span class="o">=</span> <span class="n">Map</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ol>
<p>As you can see from these examples like in function signatures type aliases support polymorphism via type variables and the type varables support partial application like functions.</p>
</div>
<div class="section" id="algebraic-datatypes">
<span id="id3"></span><h3>Algebraic datatypes<a class="headerlink" href="#algebraic-datatypes" title="Permalink to this headline">¶</a></h3>
<p>Algebraic datatypes are the &#8220;normal&#8221; user defined datatypes in Haskell.
They are richer than datatypes from other laguages such as Java classes or C structs in that each type can have more (or less) than one representation.
Some modern languages such as Rust and Swift also support those types of data.
They call them Enums.</p>
<p>A type is defined using the <code class="docutils literal"><span class="pre">data</span></code> keyword, followed by the name of the type, which must begin with an upper case letter (see also <a class="reference internal" href="syntax.html#types"><span class="std std-ref">here</span></a>), followed by an equal sign.
This is followed by any number of <code class="docutils literal"><span class="pre">|</span></code> separated <em>constructor definitions</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Coordinates</span> <span class="o">=</span> <span class="n">LongAndLat</span> <span class="n">Int</span> <span class="n">Int</span>

<span class="n">data</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Nothing</span> <span class="o">|</span> <span class="n">Just</span> <span class="n">a</span>
</pre></div>
</div>
<p>A constructor definition takes the form of first the constructor itself, followed by any number of type arguments, which are the types of the fields in the constructor.
The naming constraints for the constructor are the same as for <a class="reference internal" href="syntax.html#types"><span class="std std-ref">Type literals</span></a>.[#type-operators]</p>
<p>Constructors serve two purposes.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>They are used, through normal function application, to <em>construct</em> a value of their type.</dt>
<dd><p class="first">You can think of any constructor (like <code class="docutils literal"><span class="pre">Coordinates</span></code>) as a function, wich takes arguments according to the number and type of its fields and produces a value of its type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">LongAndLat</span> <span class="p">::</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Coordinates</span>
</pre></div>
</div>
<p>These constructors can be used just just like any other function, which includes partial application and being arguments to higher order functions.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">LongAndLat</span> <span class="mi">8</span> <span class="p">::</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Coordinates</span>

<span class="nb">map</span> <span class="p">(</span><span class="n">LongAndLat</span> <span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">9</span><span class="p">,</span> <span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">15</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p class="first">They are used in a pattern match to <em>deconstruct</em> a value of their type and gain access to its fields. (See <a class="reference internal" href="#case"><span class="std std-ref">next section</span></a>)</p>
</li>
</ol>
<p>It is very important to know the difference between a <em>type(name)</em> and a <em>constructor</em> in Haskell.
Also not that it is allowed for a type and a constructor with the same name to be in scope, as the distinction between the two can be made from the context in which they are used.
Type names only ever occur in a place where a type can occur, such as in the definition of another type and type signatures.</p>
<div class="admonition-aside admonition">
<p class="first admonition-title">Aside</p>
<p class="last">There are more ways to control type variables in Haskell using a <span class="xref std std-ref">generalised concept of algebraic datatypes</span>.</p>
</div>
</div>
<div class="section" id="newtypes">
<span id="id4"></span><h3>Newtypes<a class="headerlink" href="#newtypes" title="Permalink to this headline">¶</a></h3>
<p>Newtypes are basically a stricter version of the <code class="docutils literal"><span class="pre">type</span></code> alias.
To be more concrete a <code class="docutils literal"><span class="pre">newtype</span></code> is a wrapper for another type which completely hides the wrapped type.</p>
<p>The syntax is very similar to a <code class="docutils literal"><span class="pre">data</span></code> definition, with two important restrictions.</p>
<ol class="arabic simple">
<li>The newtype must have exactly <em>one</em> constructor.</li>
<li>The constructor must have exactly <em>one</em> field.</li>
</ol>
<p>What is so special about the newtype is that even though it may look like a <code class="docutils literal"><span class="pre">data</span></code> definition the newtype does not exist at runtime and thus has no runtime overhead.
It is typically used to impose some restrictions on the creation of a type.</p>
<p>Whereas aliases created with <code class="docutils literal"><span class="pre">type</span></code> may be used in just the same way that the type they alias can be used a <code class="docutils literal"><span class="pre">newtype</span></code> creates a completely new type and the functions which work on the inner type <em>do not</em> work on the new type.</p>
<p>In the following example for instance we force the user to go through the <code class="docutils literal"><span class="pre">createEmail</span></code> function to construct an <code class="docutils literal"><span class="pre">Email</span></code> type.
if we used a <code class="docutils literal"><span class="pre">type</span></code> alias the user could simply pass a <code class="docutils literal"><span class="pre">String</span></code> to the <code class="docutils literal"><span class="pre">sendEmail</span></code> function, becuase it is just an alias, but types created with <code class="docutils literal"><span class="pre">newtype</span></code> are distinct from the type they wrap and thus ths would cause a type error.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newtype</span> <span class="n">Email</span> <span class="o">=</span> <span class="n">Email</span> <span class="n">String</span>

<span class="n">createEmail</span> <span class="p">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Email</span>
<span class="n">createEmail</span> <span class="nb">str</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">conformsToEmailStandard</span> <span class="nb">str</span>
        <span class="n">then</span> <span class="n">Right</span> <span class="p">(</span><span class="n">Email</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">Left</span> <span class="s2">&quot;This is not a valid email&quot;</span>

<span class="n">sendEmail</span> <span class="p">::</span> <span class="n">Email</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">IO</span> <span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-case-construct">
<span id="case"></span><h2>The <code class="docutils literal"><span class="pre">case</span></code> construct<a class="headerlink" href="#the-case-construct" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">case</span></code> construct together with function application basically comprises everything which you can do in Haskell.
The <code class="docutils literal"><span class="pre">case</span></code> construct is used to deconstruct a type and gain access to the data contained withtin.</p>
<p>This is easiest to see with a user defined type</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="n">Int</span>

<span class="n">let</span> <span class="n">aValue</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="mi">5</span> <span class="p">::</span> <span class="n">MyType</span>
    <span class="n">theIntWithin</span> <span class="o">=</span>
        <span class="n">case</span> <span class="n">aValue</span> <span class="n">of</span>
            <span class="n">Constr1</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>

<span class="n">theIntWithin</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Any Haskell expression is allowed in the <code class="docutils literal"><span class="pre">case</span> <span class="pre">&lt;expr&gt;</span> <span class="pre">of</span></code> head of the construct.
The body of the case statement is a number of <code class="docutils literal"><span class="pre">matchclause</span> <span class="pre">-&gt;</span> <span class="pre">expr</span></code> pairs.</p>
<p>Each match clause is a combination of constructors and bindings for values.
The expression to the right of the arrow may then use the values bound by these bindings.</p>
<p>A very simple case match (which does absolutely nothing) would be</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">doSomething</span> <span class="n">x</span>
</pre></div>
</div>
<p>Which is the same as <code class="docutils literal"><span class="pre">doSomething</span> <span class="pre">expr</span></code>.
We simply bind the expression to <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>However this is often used to create a default clause for a case match.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="n">Int</span> <span class="o">|</span> <span class="n">Constr2</span> <span class="n">String</span>

<span class="n">let</span> <span class="n">aValue</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="mi">5</span> <span class="p">::</span> <span class="n">MyType</span>
    <span class="n">theIntWithin</span> <span class="o">=</span>
        <span class="n">case</span> <span class="n">aValue</span> <span class="n">of</span>
            <span class="n">Constr1</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
            <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Match clauses are alwas matched in sequence, from top to bottom until a matching clause is found.
A clause like <code class="docutils literal"><span class="pre">x</span></code>, which does not contain a constructor will always match.
Therefore it is usually found as the last clause, often serving as a kind of default clause.
If the default clause does not need the value we often use <code class="docutils literal"><span class="pre">_</span></code> as binding to indicate that we do not use the value.</p>
<p>The <code class="docutils literal"><span class="pre">case</span></code> is an immensely powerful control structure as all other control structures can be defined in terms of <code class="docutils literal"><span class="pre">case</span></code> and function application.
For instance we can define an <code class="docutils literal"><span class="pre">if</span></code> using case.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="k">if</span> <span class="n">cond</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
        <span class="n">case</span> <span class="n">cond</span> <span class="n">of</span>
            <span class="kc">True</span> <span class="o">-&gt;</span> <span class="n">a</span>
            <span class="kc">False</span> <span class="o">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>You can also pattern match on primitive, built-in types.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">isC</span> <span class="n">char</span> <span class="o">=</span> <span class="n">case</span> <span class="n">char</span> <span class="n">of</span>
                    <span class="s1">&#39;c&#39;</span> <span class="o">-&gt;</span> <span class="kc">True</span>
                    <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">False</span>

<span class="n">isC</span> <span class="s1">&#39;l&#39;</span> <span class="o">==</span> <span class="kc">False</span>
<span class="n">isC</span> <span class="s1">&#39;c&#39;</span> <span class="o">==</span> <span class="kc">True</span>

<span class="n">let</span> <span class="n">is4</span> <span class="n">n</span> <span class="o">=</span> <span class="n">case</span> <span class="n">n</span> <span class="n">of</span>
                <span class="mi">4</span> <span class="o">-&gt;</span> <span class="kc">True</span>
                <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">False</span>

<span class="n">is4</span> <span class="mi">4</span> <span class="o">==</span> <span class="kc">True</span>
<span class="n">is4</span> <span class="mi">0</span> <span class="o">==</span> <span class="kc">False</span>
</pre></div>
</div>
<div class="section" id="different-ways-to-write-a-case-expression">
<h3>Different ways to write a case expression<a class="headerlink" href="#different-ways-to-write-a-case-expression" title="Permalink to this headline">¶</a></h3>
<p>Case expressions can either be written using indentation, or semicolons and braces.
The following definitions are equivalent</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="o">--</span> <span class="n">note</span> <span class="n">the</span> <span class="n">indent</span> <span class="n">of</span> <span class="n">the</span> <span class="n">match</span> <span class="n">clauses</span>
    <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span> <span class="n">resultExpr</span>
    <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">resultExpr2</span>

<span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span>
        <span class="o">--</span> <span class="n">note</span> <span class="n">the</span> <span class="n">deeper</span> <span class="n">indent</span> <span class="k">for</span> <span class="n">the</span> <span class="n">result</span> <span class="n">expression</span>
        <span class="n">resultExpr</span>
    <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">resultExpr2</span>

<span class="o">--</span> <span class="n">indent</span> <span class="ow">is</span> <span class="n">replaced</span> <span class="k">with</span> <span class="n">semicolons</span> <span class="ow">and</span> <span class="n">braces</span>
<span class="n">case</span> <span class="n">expr</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span> <span class="n">resultExpr</span><span class="p">;</span> <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">resultExpr2</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-variables-and-special-types">
<span id="type-variables"></span><h2>Type variables and special types<a class="headerlink" href="#type-variables-and-special-types" title="Permalink to this headline">¶</a></h2>
<p>Types in Haskell may be parameterized over another type, which is not known at the time of defining the former type.
This system is very similar to generics in many languages, but much more powerful as the type information is fully preserved.</p>
<p>The naming rules for type variables are the same as for <a class="reference internal" href="syntax.html#bindings"><span class="std std-ref">Bindings</span></a>. <a href="#id10"><span class="problematic" id="id11"><span id="id5"></span>[#naming-convention]_</span></a></p>
<p>The whole type is then written as first the type name followed by a space and then followed by the parameters, also space separated.
This is also called juxtaposition.</p>
<p>As an example for a parameterized type is the <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code> type.
The name of the type is <code class="docutils literal"><span class="pre">Either</span></code> and it is parameterized by a type variable <code class="docutils literal"><span class="pre">a</span></code> and a type variable <code class="docutils literal"><span class="pre">b</span></code>.
Note that there is no special significance to the name of the type variables themselves.
It would be semantically equivalent to call the type <code class="docutils literal"><span class="pre">Either</span> <span class="pre">one</span> <span class="pre">the_other</span></code>.
Only if we were to name both variables the same would we change the meaning, because <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">a</span></code> would mean <strong>both</strong> types <code class="docutils literal"><span class="pre">Either</span></code> is parameterized over are the <strong>same</strong> type.</p>
<p>We have now seen the type in its generic form.
By instantiating the type variables we can create a concrete form.
For instance <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">String</span></code> or <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Bool</span> <span class="pre">Char</span></code>.
Note that <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code> does not mean that <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> <strong>have</strong> to be distinct, but they are allowed to.
<code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">Int</span></code> is also a perfectly valid concrete form of <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>.</p>
<p>At compile time all of the type parameters must be known, i.e. only concrete form of types are allowed.
The compiler will infer the concrete values of the type variables for you.</p>
<div class="section" id="special-types">
<span id="id6"></span><h3>Special types<a class="headerlink" href="#special-types" title="Permalink to this headline">¶</a></h3>
<p>There are some notable exceptions to the type naming rule above.
Those are the <strong>list type</strong>, which is <code class="docutils literal"><span class="pre">[]</span></code> or <code class="docutils literal"><span class="pre">[a]</span></code> which means &#8220;a list containing elements of type <code class="docutils literal"><span class="pre">a</span></code>&#8221; and the <strong>tuple type</strong> <code class="docutils literal"><span class="pre">(a,b)</span></code> for &#8220;a 2-tuple containing a value of type <code class="docutils literal"><span class="pre">a</span></code> and a value of type <code class="docutils literal"><span class="pre">b</span></code>&#8221;.
There are also larger tuples <code class="docutils literal"><span class="pre">(a,b,c)</span></code>, <code class="docutils literal"><span class="pre">(a,b,c,d)</span></code> etc. <a href="#id12"><span class="problematic" id="id13"><span id="id7"></span>[#tuple-size]_</span></a>
These tuples are simply grouped data and very common in mathematics for instance.
Should you not be familiar with the mathematical notion of tuples it may help to think of it as an unnamed struct where the fields are accessed by &#8220;index&#8221;.
And the last special type is the <strong>function type</strong> <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, which reads &#8220;a function taking as input a value of type <code class="docutils literal"><span class="pre">a</span></code> and producing a value of type <code class="docutils literal"><span class="pre">b</span></code>.</p>
<p>Some examples for concrete instances of special types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">myIntBoolTriple</span> <span class="p">::</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Bool</span><span class="p">)</span>
    <span class="n">myIntBoolTriple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">let</span> <span class="n">aWordList</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">]</span> <span class="p">::</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="o">--</span> <span class="n">Note</span><span class="p">:</span> <span class="n">A</span> <span class="n">different</span> <span class="n">way</span> <span class="n">to</span> <span class="n">annotate</span> <span class="n">the</span> <span class="nb">type</span>

<span class="o">--</span> <span class="n">Note</span><span class="p">:</span> <span class="n">we</span> <span class="n">can</span> <span class="n">also</span> <span class="n">nest</span> <span class="n">these</span> <span class="n">types</span>
<span class="n">let</span> <span class="n">listOfTuples</span> <span class="p">::</span> <span class="p">[(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)]</span>
    <span class="n">listOfTuples</span> <span class="o">=</span>
        <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Marco&quot;</span><span class="p">)</span>
        <span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s2">&quot;Janine&quot;</span><span class="p">)</span>
        <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="record-syntax">
<span id="id8"></span><h2>Record syntax<a class="headerlink" href="#record-syntax" title="Permalink to this headline">¶</a></h2>
<p>For convenience reasons there is some extra syntax for defining data types which also automatically creates some field accessor functions.</p>
<p>We can write the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">TyType</span> <span class="o">=</span>
    <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field1</span> <span class="p">::</span> <span class="n">Int</span>
                <span class="p">,</span> <span class="n">field2</span> <span class="p">::</span> <span class="n">String</span>
                <span class="p">}</span>
</pre></div>
</div>
<p>This defines the type the same way as the other <code class="docutils literal"><span class="pre">data</span></code> construct.
Meaning we can pattern match as usual on the constructor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="n">Int</span> <span class="n">String</span>

<span class="n">let</span> <span class="n">theData</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="mi">9</span> <span class="s2">&quot;hello&quot;</span> <span class="p">::</span> <span class="n">MyType</span>
<span class="n">let</span> <span class="n">theInt</span> <span class="o">=</span> <span class="n">case</span> <span class="n">theData</span> <span class="n">of</span>
                <span class="n">Constructor</span> <span class="n">i</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">i</span>

<span class="n">theInt</span> <span class="o">==</span> <span class="mi">9</span>
</pre></div>
</div>
<p>But additionally it also defines two functions <code class="docutils literal"><span class="pre">field1</span></code> and <code class="docutils literal"><span class="pre">field2</span></code> for accessing the fields.</p>
<p>Aka it generates code similar to the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="n">Int</span> <span class="n">String</span>

<span class="n">field1</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">field1</span> <span class="p">(</span><span class="n">Constructor</span> <span class="n">i</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>

<span class="n">field2</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">field2</span> <span class="p">(</span><span class="n">Constructor</span> <span class="n">_</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span>
</pre></div>
</div>
<p>Also the two accessor functions <code class="docutils literal"><span class="pre">field1</span></code> and <code class="docutils literal"><span class="pre">field2</span></code> may be used in a special <em>record update syntax</em> to create a new record from an old one with altered field contents.
Additionally the record may be created with a special record creation syntax.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">TyType</span> <span class="o">=</span>
    <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field1</span> <span class="p">::</span> <span class="n">Int</span>
                <span class="p">,</span> <span class="n">field2</span> <span class="p">::</span> <span class="n">String</span>
                <span class="p">}</span>

<span class="n">let</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="mi">9</span> <span class="s2">&quot;Hello&quot;</span> <span class="p">::</span> <span class="n">MyType</span>

<span class="o">--</span> <span class="n">record</span> <span class="n">creation</span> <span class="n">syntax</span>
<span class="n">let</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field2</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span><span class="p">,</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">}</span> <span class="p">::</span> <span class="n">MyType</span>

<span class="o">--</span> <span class="n">update</span> <span class="n">syntax</span>
<span class="n">let</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">v2</span> <span class="p">{</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">}</span>
<span class="o">--</span> <span class="n">updating</span> <span class="n">multiple</span> <span class="n">fields</span> <span class="n">at</span> <span class="n">once</span>
<span class="n">let</span> <span class="n">v4</span> <span class="o">=</span> <span class="n">v2</span> <span class="p">{</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">field2</span> <span class="s2">&quot;Hello&quot;</span> <span class="p">}</span>

<span class="n">v1</span> <span class="o">==</span> <span class="n">v4</span>

<span class="o">--</span> <span class="n">old</span> <span class="n">records</span> <span class="n">are</span> <span class="n">unchanged</span>
<span class="n">v2</span> <span class="o">/=</span> <span class="n">v3</span> <span class="o">/=</span> <span class="n">v4</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Types</a><ul>
<li><a class="reference internal" href="#user-defined-types">User defined types</a><ul>
<li><a class="reference internal" href="#aliases">Aliases</a></li>
<li><a class="reference internal" href="#algebraic-datatypes">Algebraic datatypes</a></li>
<li><a class="reference internal" href="#newtypes">Newtypes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-case-construct">The <code class="docutils literal"><span class="pre">case</span></code> construct</a><ul>
<li><a class="reference internal" href="#different-ways-to-write-a-case-expression">Different ways to write a case expression</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-variables-and-special-types">Type variables and special types</a><ul>
<li><a class="reference internal" href="#special-types">Special types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#record-syntax">Record syntax</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/types.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Justus Adam.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/types.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>