<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. Types &#8212; Haskell Lessons 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Exercises" href="exercises/index.html" />
    <link rel="prev" title="3. Functions" href="functions.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="types">
<span id="id1"></span><h1>4. Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<div class="section" id="type-variables">
<span id="id2"></span><h2>4.1. Type variables<a class="headerlink" href="#type-variables" title="Permalink to this headline">¶</a></h2>
<p>Types in Haskell may be parameterized over another type, which is not known at the time of defining the former type.
This system is very similar to generics in many languages, but much more powerful as the type information is fully preserved.</p>
<p>The naming rules for type variables are the same as for <a class="reference internal" href="syntax.html#bindings"><span class="std std-ref">Bindings</span></a>. <a class="footnote-reference" href="#naming-convention" id="id3">[1]</a></p>
<p>The whole type is then written as first the type name followed by a space and then followed by the parameters, also space separated.
This is also called juxtaposition.</p>
<p>As an example for a parameterized type is the <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code> type.
The name of the type is <code class="docutils literal"><span class="pre">Either</span></code> and it is parameterized by a type variable <code class="docutils literal"><span class="pre">a</span></code> and a type variable <code class="docutils literal"><span class="pre">b</span></code>.
Note that there is no special significance to the name of the type variables themselves.
It would be semantically equivalent to call the type <code class="docutils literal"><span class="pre">Either</span> <span class="pre">one</span> <span class="pre">the_other</span></code>.
Only if we were to name both variables the same would we change the meaning, because <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">a</span></code> would mean <strong>both</strong> types <code class="docutils literal"><span class="pre">Either</span></code> is parameterized over are the <strong>same</strong> type.</p>
<p>We have now seen the type in its generic form.
By instantiating the type variables we can create a concrete form.
For instance <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">String</span></code> or <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Bool</span> <span class="pre">Char</span></code>.
Note that <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code> does not mean that <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> <strong>have</strong> to be distinct, but they are allowed to.
<code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span> <span class="pre">Int</span></code> is also a perfectly valid concrete form of <code class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>.</p>
<p>At compile time all of the type parameters must be known, i.e. only concrete form of types are allowed.
The compiler will infer the concrete values of the type variables for you.</p>
<p>Note that if you wish to annotate a type which uses type variables you will have to fill in the concrete types for those variables <em>unless</em> they are unused.
An example:</p>
<p>As you can see from the definition of <code class="docutils literal"><span class="pre">Either</span></code> each type variable is used in one of the constructors.
If you now create one of theses values and whish to annotate it with a type you have to fill in the respective typ variable.
However you do not have to fill in the second variable.
For instance if you create a <code class="docutils literal"><span class="pre">Left</span></code> value, lets say containing a <code class="docutils literal"><span class="pre">String</span></code> it does not matter what type <code class="docutils literal"><span class="pre">b</span></code> is in the resulting <code class="docutils literal"><span class="pre">Either</span></code>, becuase the <code class="docutils literal"><span class="pre">Left</span></code> constructor only uses the <code class="docutils literal"><span class="pre">a</span></code> variable and therefore the compiler will allow you to write anything for <code class="docutils literal"><span class="pre">a</span></code> including a type variable (which means it can be anything).
If however you have an expression like the <code class="docutils literal"><span class="pre">if</span></code> which may either return <code class="docutils literal"><span class="pre">Left</span></code> or <code class="docutils literal"><span class="pre">Right</span></code> you have to fill in both types properly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Right</span> <span class="n">b</span>

<span class="n">x</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">b</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Left</span> <span class="s2">&quot;A String&quot;</span>
<span class="n">y</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">a</span> <span class="n">Int</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Right</span> <span class="mi">1</span>

<span class="n">x_and_y</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Int</span>
<span class="n">x_and_y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">someBool</span> <span class="n">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>We could also have annotated <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> with concrete types for the respective other variable, however in that case we must make it the type the <code class="docutils literal"><span class="pre">if</span></code> expression expects it to be or we get a type error.
Therefore is is usually advisable to leave the type unspecified unless necessary.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Right</span> <span class="n">b</span>

<span class="o">--</span> <span class="n">these</span> <span class="n">definitions</span> <span class="n">are</span> <span class="n">ok</span>
<span class="o">--</span> <span class="n">because</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">lines</span> <span class="n">up</span> <span class="k">with</span> <span class="n">the</span> <span class="k">if</span> <span class="n">expression</span>

<span class="n">x</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Int</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Left</span> <span class="s2">&quot;A String&quot;</span>
<span class="n">y</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Int</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Right</span> <span class="mi">1</span>

<span class="o">--</span> <span class="n">these</span> <span class="n">definitions</span> <span class="n">are</span> <span class="n">problematic</span>
<span class="o">--</span> <span class="n">they</span> <span class="n">would</span> <span class="n">cause</span> <span class="n">a</span> <span class="nb">type</span> <span class="n">error</span>

<span class="n">x</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Bool</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Left</span> <span class="s2">&quot;A String&quot;</span>
<span class="n">y</span> <span class="p">::</span> <span class="n">Either</span> <span class="p">(</span><span class="n">Either</span> <span class="n">String</span> <span class="n">String</span><span class="p">)</span> <span class="n">Int</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Right</span> <span class="mi">1</span>

<span class="n">x_and_y</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Int</span>
<span class="n">x_and_y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">someBool</span> <span class="n">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>If you don&#8217;t know the type of an expression but wish to annotate it or you dont know the value of one of the type variables you can use a so called &#8220;type hole&#8221; to have the compiler figure it out for you.
If you annotate an expression with <code class="docutils literal"><span class="pre">_</span></code> the compiler will throw an error and tell you what it infers the type for <code class="docutils literal"><span class="pre">_</span></code> to be.
You can use multiple <code class="docutils literal"><span class="pre">_</span></code> at the same time each of which will cause a compile error with information about the inferred type.
This can be used for full type signatures or even just parts of it, including type variables.
GHC generally tries to infer the most general type for you.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">infer</span> <span class="n">a</span> <span class="n">full</span> <span class="nb">type</span> <span class="n">signature</span>
<span class="n">x</span> <span class="p">::</span> <span class="n">_</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Left</span> <span class="s2">&quot;A String&quot;</span>

<span class="o">--</span> <span class="n">Infer</span> <span class="n">a</span> <span class="n">variable</span>
<span class="n">y</span> <span class="p">::</span> <span class="n">Either</span> <span class="n">a</span> <span class="n">_</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Right</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-types">
<span id="id4"></span><h2>4.2. User defined types<a class="headerlink" href="#user-defined-types" title="Permalink to this headline">¶</a></h2>
<p>Defining types in Haskell takes three forms.</p>
<div class="section" id="aliases">
<span id="type-alases"></span><h3>4.2.1. Aliases<a class="headerlink" href="#aliases" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">type</span></code> keyword allows us to define a new name for an existing type.
This can have two different purposes:</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>It allows us to define shorter names for long type.</dt>
<dd><p class="first">For instance</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MakerM</span> <span class="n">a</span> <span class="o">=</span> <span class="n">StateT</span> <span class="p">(</span><span class="n">ALongStateName</span> <span class="n">String</span> <span class="n">Bool</span> <span class="p">(</span><span class="n">HashMap</span> <span class="n">Text</span> <span class="n">Int</span><span class="p">))</span> <span class="p">(</span><span class="n">LoggingT</span> <span class="n">IO</span><span class="p">)</span> <span class="n">a</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>We can abstract our API from the concrete type.</dt>
<dd><p class="first">If our program uses a Map like structure for instance, but we are not sure yet that we want to stick with a concrete Map type we might write the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>type MyMap key value = HashMap key value
-- or (omitting the `value` variable)
type MyMap key = HashMap key
-- or (omitting both the `value` and `key` variable)
type MyMap = HashMap
</pre></div>
</div>
<p>We can then later replace it with a different map type if we like and we do not need to change all of our type signatures.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MyMap</span> <span class="o">=</span> <span class="n">Map</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ol>
<p>As you can see from these examples like in function signatures type aliases support polymorphism via type variables and the type varables support partial application like functions.</p>
</div>
<div class="section" id="algebraic-datatypes">
<span id="id5"></span><h3>4.2.2. Algebraic datatypes<a class="headerlink" href="#algebraic-datatypes" title="Permalink to this headline">¶</a></h3>
<p>Algebraic datatypes are the &#8220;normal&#8221; user defined datatypes in Haskell.
They are richer than datatypes from other laguages such as Java classes or C structs in that each type can have more (or less) than one representation.
Some modern languages such as Rust and Swift also support those types of data.
They call them Enums.</p>
<p>A type is defined using the <code class="docutils literal"><span class="pre">data</span></code> keyword, followed by the name of the type, which must begin with an upper case letter (see also <a class="reference internal" href="#types"><span class="std std-ref">here</span></a>), followed by an equal sign.
This is followed by any number of <code class="docutils literal"><span class="pre">|</span></code> separated <em>constructor definitions</em>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Coordinates</span> <span class="o">=</span> <span class="n">LongAndLat</span> <span class="n">Int</span> <span class="n">Int</span>

<span class="n">data</span> <span class="n">File</span> <span class="o">=</span> <span class="n">TextFile</span> <span class="n">String</span> <span class="o">|</span> <span class="n">Binary</span> <span class="n">Bytes</span>
</pre></div>
</div>
<p>A constructor definition takes the form of first the constructor itself, followed by any number of type arguments, which are the types of the fields in the constructor.
The naming constraints for the constructor are the same as for <a class="reference internal" href="#types"><span class="std std-ref">Types</span></a>.[#type-operators]</p>
<p>Constructors serve two purposes.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>They are used, through normal function application, to <em>construct</em> a value of their type.</dt>
<dd><p class="first">You can think of any constructor (like <code class="docutils literal"><span class="pre">Coordinates</span></code>) as a function, wich takes arguments according to the number and type of its fields and produces a value of its type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">LongAndLat</span> <span class="p">::</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Coordinates</span>
</pre></div>
</div>
<p>These constructors can be used just just like any other function, which includes partial application and being arguments to higher order functions.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">LongAndLat</span> <span class="mi">8</span> <span class="p">::</span> <span class="n">Int</span> <span class="o">-&gt;</span> <span class="n">Coordinates</span>

<span class="nb">map</span> <span class="p">(</span><span class="n">LongAndLat</span> <span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">9</span><span class="p">,</span> <span class="n">LongAndLat</span> <span class="mi">9</span> <span class="mi">15</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p class="first">They are used in a pattern match to <em>deconstruct</em> a value of their type and gain access to its fields. (See <a class="reference internal" href="#case"><span class="std std-ref">next section</span></a>)</p>
</li>
</ol>
<p>It is very important to know the difference between a <em>type(name)</em> and a <em>constructor</em> in Haskell.
Also not that it is allowed for a type and a constructor with the same name to be in scope, as the distinction between the two can be made from the context in which they are used.
Type names only ever occur in a place where a type can occur, such as in the definition of another type and type signatures whereas a <em>Constructor</em> can occur in any epression.</p>
</div>
<div class="section" id="newtypes">
<span id="id6"></span><h3>4.2.3. Newtypes<a class="headerlink" href="#newtypes" title="Permalink to this headline">¶</a></h3>
<p>Newtypes are basically a stricter version of the <code class="docutils literal"><span class="pre">type</span></code> alias.
To be more concrete a <code class="docutils literal"><span class="pre">newtype</span></code> is a wrapper for another type which completely hides the wrapped type.</p>
<p>The syntax is very similar to a <code class="docutils literal"><span class="pre">data</span></code> definition, with two important restrictions.</p>
<ol class="arabic simple">
<li>The newtype must have exactly <em>one</em> constructor.</li>
<li>The constructor must have exactly <em>one</em> field.</li>
</ol>
<p>What is so special about the newtype is that even though it may look like a <code class="docutils literal"><span class="pre">data</span></code> definition the newtype does not exist at runtime and thus has no runtime overhead.
It is typically used to impose some restrictions on the creation of a type.</p>
<p>Whereas aliases created with <code class="docutils literal"><span class="pre">type</span></code> may be used in just the same way that the type they alias can be used a <code class="docutils literal"><span class="pre">newtype</span></code> creates a completely new type and the functions which work on the inner type <em>do not</em> work on the new type.</p>
<p>In the following example for instance we force the user to go through the <code class="docutils literal"><span class="pre">createEmail</span></code> function to construct an <code class="docutils literal"><span class="pre">Email</span></code> type.
if we used a <code class="docutils literal"><span class="pre">type</span></code> alias the user could simply pass a <code class="docutils literal"><span class="pre">String</span></code> to the <code class="docutils literal"><span class="pre">sendEmail</span></code> function, becuase it is just an alias, but types created with <code class="docutils literal"><span class="pre">newtype</span></code> are distinct from the type they wrap and thus ths would cause a type error.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newtype</span> <span class="n">Email</span> <span class="o">=</span> <span class="n">Email</span> <span class="n">String</span>

<span class="n">createEmail</span> <span class="p">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">Either</span> <span class="n">String</span> <span class="n">Email</span>
<span class="n">createEmail</span> <span class="nb">str</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">conformsToEmailStandard</span> <span class="nb">str</span>
        <span class="n">then</span> <span class="n">Right</span> <span class="p">(</span><span class="n">Email</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">Left</span> <span class="s2">&quot;This is not a valid email&quot;</span>

<span class="n">sendEmail</span> <span class="p">::</span> <span class="n">Email</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">IO</span> <span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-type-variables">
<h3>4.2.4. Using type variables<a class="headerlink" href="#using-type-variables" title="Permalink to this headline">¶</a></h3>
<p>To use a type variable in a type you are defining yourself there is a very simple rule.
You may use as many type variables as you like.
Any type variable you use on the <em>right</em> side of the equal sign <em>must</em> also occur on the <em>left</em> side.
Basically on the left you declare which variables the type is abstracted over and on the right you may use it as a type for your fields. <a class="footnote-reference" href="#unused-type-variables" id="id7">[3]</a></p>
<p>Some examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Nothing</span>

<span class="n">data</span> <span class="n">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Right</span> <span class="n">b</span>

<span class="n">newtype</span> <span class="n">SetWrapper</span> <span class="n">a</span> <span class="o">=</span> <span class="n">SetWrapper</span> <span class="p">(</span><span class="n">Set</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-aside admonition">
<p class="first admonition-title">Aside</p>
<p class="last">There are more ways to control type variables in Haskell using a <span class="xref std std-ref">generalised concept of algebraic datatypes</span>.</p>
</div>
</div>
</div>
<div class="section" id="the-case-construct">
<span id="case"></span><h2>4.3. The <code class="docutils literal"><span class="pre">case</span></code> construct<a class="headerlink" href="#the-case-construct" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">case</span></code> construct together with function application basically comprises everything which you can do in Haskell.
The <code class="docutils literal"><span class="pre">case</span></code> construct is used to deconstruct a type and gain access to the data contained withtin.</p>
<p>This is easiest to see with a user defined type</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="n">Int</span>

<span class="n">aValue</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="mi">5</span> <span class="p">::</span> <span class="n">MyType</span>
<span class="n">theIntWithin</span> <span class="o">=</span>
    <span class="n">case</span> <span class="n">aValue</span> <span class="n">of</span>
        <span class="n">Constr1</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>

<span class="n">theIntWithin</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Any Haskell expression is allowed in the <code class="docutils literal"><span class="pre">case</span> <span class="pre">&lt;expr&gt;</span> <span class="pre">of</span></code> head of the construct.
The body of the case statement is a number of <code class="docutils literal"><span class="pre">matchclause</span> <span class="pre">-&gt;</span> <span class="pre">expr</span></code> pairs.</p>
<p>Each match clause is a combination of constructors and bindings for values.
The expression to the right of the arrow may then use the values bound by these bindings.</p>
<p>A very simple case match (which does absolutely nothing) would be</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">doSomething</span> <span class="n">x</span>
</pre></div>
</div>
<p>Which is the same as <code class="docutils literal"><span class="pre">doSomething</span> <span class="pre">expr</span></code>.
We simply bind the expression to <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>However this is often used to create a default clause for a case match.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="n">Int</span> <span class="o">|</span> <span class="n">Constr2</span> <span class="n">String</span>

<span class="n">aValue</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="mi">5</span> <span class="p">::</span> <span class="n">MyType</span>
<span class="n">theIntWithin</span> <span class="o">=</span>
    <span class="n">case</span> <span class="n">aValue</span> <span class="n">of</span>
        <span class="n">Constr1</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Match clauses are always matched in sequence, from top to bottom until a matching clause is found.
A clause like <code class="docutils literal"><span class="pre">x</span></code>, which does not contain a constructor will always match.
Therefore it is usually found as the last clause, often serving as a kind of default clause.
If the default clause does not need the value we often use <code class="docutils literal"><span class="pre">_</span></code> as binding to indicate that we do not use the value.</p>
<p>The <code class="docutils literal"><span class="pre">case</span></code> is an immensely powerful control structure as all other control structures can be defined in terms of <code class="docutils literal"><span class="pre">case</span></code> and function application.
For instance we can define an <code class="docutils literal"><span class="pre">if</span></code> using case.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">cond</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
    <span class="n">case</span> <span class="n">cond</span> <span class="n">of</span>
        <span class="kc">True</span> <span class="o">-&gt;</span> <span class="n">a</span>
        <span class="kc">False</span> <span class="o">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>You can also pattern match on all primitive, built-in types such as <code class="docutils literal"><span class="pre">Char</span></code>, <code class="docutils literal"><span class="pre">[]</span></code>, <code class="docutils literal"><span class="pre">String</span></code>, <code class="docutils literal"><span class="pre">Int</span></code>, <code class="docutils literal"><span class="pre">Float</span></code> and so on. Anything you can write as a literal you may use in a case pattern.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">isC</span> <span class="n">char</span> <span class="o">=</span> <span class="n">case</span> <span class="n">char</span> <span class="n">of</span>
                <span class="s1">&#39;c&#39;</span> <span class="o">-&gt;</span> <span class="kc">True</span>
                <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">False</span>

<span class="n">isC</span> <span class="s1">&#39;l&#39;</span> <span class="o">==</span> <span class="kc">False</span>
<span class="n">isC</span> <span class="s1">&#39;c&#39;</span> <span class="o">==</span> <span class="kc">True</span>

<span class="n">is4</span> <span class="n">n</span> <span class="o">=</span> <span class="n">case</span> <span class="n">n</span> <span class="n">of</span>
            <span class="mi">4</span> <span class="o">-&gt;</span> <span class="kc">True</span>
            <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">False</span>

<span class="n">is4</span> <span class="mi">4</span> <span class="o">==</span> <span class="kc">True</span>
<span class="n">is4</span> <span class="mi">0</span> <span class="o">==</span> <span class="kc">False</span>
</pre></div>
</div>
<div class="section" id="different-ways-to-write-a-case-expression">
<h3>4.3.1. Different ways to write a case expression<a class="headerlink" href="#different-ways-to-write-a-case-expression" title="Permalink to this headline">¶</a></h3>
<p>Case expressions can either be written using indentation, or semicolons and braces in the same way we can do with <code class="docutils literal"><span class="pre">let</span></code>.
Thereby we can use <code class="docutils literal"><span class="pre">;</span></code> to omit newlines and <code class="docutils literal"><span class="pre">{}</span></code> to omit the indentation.
The following definitions are equivalent</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="o">--</span> <span class="n">note</span> <span class="n">the</span> <span class="n">indent</span> <span class="n">of</span> <span class="n">the</span> <span class="n">match</span> <span class="n">clauses</span>
    <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span> <span class="n">resultExpr</span>
    <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">resultExpr2</span>

<span class="n">case</span> <span class="n">expr</span> <span class="n">of</span>
    <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span>
        <span class="o">--</span> <span class="n">note</span> <span class="n">the</span> <span class="n">deeper</span> <span class="n">indent</span> <span class="k">for</span> <span class="n">the</span> <span class="n">result</span> <span class="n">expression</span>
        <span class="n">resultExpr</span>
    <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span>
        <span class="n">resultExpr2</span>

<span class="o">--</span> <span class="n">indent</span> <span class="ow">is</span> <span class="n">replaced</span> <span class="k">with</span> <span class="n">semicolons</span> <span class="ow">and</span> <span class="n">braces</span>
<span class="n">case</span> <span class="n">expr</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Constr1</span> <span class="n">field1</span> <span class="n">field2</span> <span class="o">-&gt;</span> <span class="n">resultExpr</span><span class="p">;</span> <span class="n">Constr2</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">resultExpr2</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="case-match-in-function-definition">
<h3>4.3.2. Case match in function definition<a class="headerlink" href="#case-match-in-function-definition" title="Permalink to this headline">¶</a></h3>
<p>A very common pattern in Haskell is to have a function and then directly perform a <code class="docutils literal"><span class="pre">case</span></code> match on one or more of the arguments.
There is some syntactic sugar to make this more convenient.</p>
<p>If you define your function with the syntax where the arguments come before the <code class="docutils literal"><span class="pre">=</span></code> you can directly perform a pattern match on them there.
Mutliple <code class="docutils literal"><span class="pre">case</span></code> options are hereby achieved by defining the function once for each option.
Note that in this pattern match constructors with more than zero fields need to be parenthesized (otherwise how can the compiler distinguish between field bindings and the next argument?).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constr1</span> <span class="n">Int</span> <span class="o">|</span> <span class="n">Constr2</span> <span class="n">String</span>

<span class="o">--</span> <span class="n">before</span>
<span class="n">getTheInt</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">getTheInt</span> <span class="n">t</span> <span class="o">=</span>
    <span class="n">case</span> <span class="n">t</span> <span class="n">of</span>
        <span class="n">Constr1</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="n">Consrt2</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="mi">0</span>

<span class="o">--</span> <span class="n">after</span>
<span class="n">getTheInt2</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">getTheInt2</span> <span class="p">(</span><span class="n">Constr1</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
<span class="n">getTheInt2</span> <span class="p">(</span><span class="n">Constr2</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>

<span class="o">--</span> <span class="ow">or</span><span class="p">,</span> <span class="n">alternatively</span> <span class="k">with</span> <span class="n">a</span> <span class="s2">&quot;_&quot;</span> <span class="n">default</span> <span class="n">case</span>
<span class="n">getTheInt2</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">getTheInt2</span> <span class="p">(</span><span class="n">Constr1</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
<span class="n">getTheInt2</span> <span class="n">_</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>You can also match on multiple arguments at the same time.
(I have aligned the arguments so you can better see the different patterns, this is only for readability and not necessary.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">addTheInts</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">addTheInts</span> <span class="p">(</span><span class="n">Constr1</span> <span class="n">i1</span><span class="p">)</span> <span class="p">(</span><span class="n">Constr1</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span>
<span class="n">addTheInts</span> <span class="p">(</span><span class="n">Constr</span> <span class="n">i</span><span class="p">)</span>   <span class="n">_</span>            <span class="o">=</span> <span class="n">i</span>
<span class="n">addTheInts</span> <span class="n">_</span>            <span class="p">(</span><span class="n">Constr</span> <span class="n">i</span><span class="p">)</span>   <span class="o">=</span> <span class="n">i</span>
<span class="n">addTheInts</span> <span class="n">_</span>            <span class="n">_</span>            <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="special-types">
<span id="id8"></span><h2>4.4. Special types<a class="headerlink" href="#special-types" title="Permalink to this headline">¶</a></h2>
<p>There are some notable exceptions to the type naming rule.
Those are the <strong>list type</strong>, which is <code class="docutils literal"><span class="pre">[]</span></code> or <code class="docutils literal"><span class="pre">[a]</span></code> which means &#8220;a list containing elements of type <code class="docutils literal"><span class="pre">a</span></code>&#8221; and the <strong>tuple type</strong> <code class="docutils literal"><span class="pre">(a,b)</span></code> for &#8220;a 2-tuple containing a value of type <code class="docutils literal"><span class="pre">a</span></code> and a value of type <code class="docutils literal"><span class="pre">b</span></code>&#8221;.
There are also larger tuples <code class="docutils literal"><span class="pre">(a,b,c)</span></code>, <code class="docutils literal"><span class="pre">(a,b,c,d)</span></code> etc. <a class="footnote-reference" href="#tuple-size" id="id9">[2]</a>
These tuples are simply grouped data and very common in mathematics for instance.
Should you not be familiar with the mathematical notion of tuples it may help to think of it as an unnamed struct where the fields are accessed by &#8220;index&#8221;.
And the last special type is the <strong>function type</strong> <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, which reads &#8220;a function taking as input a value of type <code class="docutils literal"><span class="pre">a</span></code> and producing a value of type <code class="docutils literal"><span class="pre">b</span></code>.</p>
<p>Some examples for concrete instances of special types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">myIntBoolTriple</span> <span class="p">::</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Bool</span><span class="p">)</span>
<span class="n">myIntBoolTriple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">aWordList</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">]</span> <span class="p">::</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="o">--</span> <span class="n">Note</span><span class="p">:</span> <span class="n">A</span> <span class="n">different</span> <span class="n">way</span> <span class="n">to</span> <span class="n">annotate</span> <span class="n">the</span> <span class="nb">type</span>

<span class="o">--</span> <span class="n">Note</span><span class="p">:</span> <span class="n">we</span> <span class="n">can</span> <span class="n">also</span> <span class="n">nest</span> <span class="n">these</span> <span class="n">types</span>
<span class="n">listOfTuples</span> <span class="p">::</span> <span class="p">[(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)]</span>
<span class="n">listOfTuples</span> <span class="o">=</span>
    <span class="p">[</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Marco&quot;</span><span class="p">)</span>
    <span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s2">&quot;Janine&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="record-syntax">
<span id="id10"></span><h2>4.5. Record syntax<a class="headerlink" href="#record-syntax" title="Permalink to this headline">¶</a></h2>
<p>For convenience reasons there is some extra syntax for defining data types which also automatically creates some field accessor functions.</p>
<p>We can write the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span>
    <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field1</span> <span class="p">::</span> <span class="n">Int</span>
                <span class="p">,</span> <span class="n">field2</span> <span class="p">::</span> <span class="n">String</span>
                <span class="p">}</span>
</pre></div>
</div>
<p>This defines the type the same way as the other <code class="docutils literal"><span class="pre">data</span></code> construct.
Meaning we can pattern match as usual on the constructor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">theData</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="mi">9</span> <span class="s2">&quot;hello&quot;</span> <span class="p">::</span> <span class="n">MyType</span>
<span class="n">theInt</span> <span class="o">=</span> <span class="n">case</span> <span class="n">theData</span> <span class="n">of</span>
            <span class="n">Constructor</span> <span class="n">i</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">i</span>

<span class="n">theInt</span> <span class="o">==</span> <span class="mi">9</span>
</pre></div>
</div>
<p>But additionally it also defines two functions <code class="docutils literal"><span class="pre">field1</span></code> and <code class="docutils literal"><span class="pre">field2</span></code> for accessing the fields.</p>
<p>Aka it generates code similar to the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="n">Int</span> <span class="n">String</span>

<span class="n">field1</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">field1</span> <span class="p">(</span><span class="n">Constructor</span> <span class="n">i</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>

<span class="n">field2</span> <span class="p">::</span> <span class="n">MyType</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">field2</span> <span class="p">(</span><span class="n">Constructor</span> <span class="n">_</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span>
</pre></div>
</div>
<p>Also the two accessor functions <code class="docutils literal"><span class="pre">field1</span></code> and <code class="docutils literal"><span class="pre">field2</span></code> may be used in a special <em>record update syntax</em> to create a new record from an old one with altered field contents.
Additionally the record may be created with a special record creation syntax.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">MyType</span> <span class="o">=</span>
    <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field1</span> <span class="p">::</span> <span class="n">Int</span>
                <span class="p">,</span> <span class="n">field2</span> <span class="p">::</span> <span class="n">String</span>
                <span class="p">}</span>

<span class="n">v1</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="mi">9</span> <span class="s2">&quot;Hello&quot;</span> <span class="p">::</span> <span class="n">MyType</span>

<span class="o">--</span> <span class="n">record</span> <span class="n">creation</span> <span class="n">syntax</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="p">{</span> <span class="n">field2</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span><span class="p">,</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">}</span> <span class="p">::</span> <span class="n">MyType</span>

<span class="o">--</span> <span class="n">update</span> <span class="n">syntax</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">v2</span> <span class="p">{</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">}</span>
<span class="o">--</span> <span class="n">updating</span> <span class="n">multiple</span> <span class="n">fields</span> <span class="n">at</span> <span class="n">once</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">v2</span> <span class="p">{</span> <span class="n">field1</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">field2</span> <span class="s2">&quot;Hello&quot;</span> <span class="p">}</span>

<span class="n">v1</span> <span class="o">==</span> <span class="n">v4</span>

<span class="o">--</span> <span class="n">old</span> <span class="n">records</span> <span class="n">are</span> <span class="n">unchanged</span>
<span class="n">v2</span> <span class="o">/=</span> <span class="n">v3</span> <span class="o">/=</span> <span class="n">v4</span>
</pre></div>
</div>
<p>And finally it also enables a special record pattern match using the fields.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">theData</span> <span class="o">=</span> <span class="n">Constructor</span> <span class="mi">9</span> <span class="s2">&quot;hello&quot;</span> <span class="p">::</span> <span class="n">MyType</span>

<span class="n">theInt</span> <span class="o">=</span> <span class="n">case</span> <span class="n">theData</span> <span class="n">of</span>
            <span class="n">Constructor</span><span class="p">{</span> <span class="n">field1</span> <span class="o">=</span> <span class="n">i</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">i</span>

<span class="n">theInt</span> <span class="o">==</span> <span class="mi">9</span>
</pre></div>
</div>
<p class="rubric">footnotes</p>
<table class="docutils footnote" frame="void" id="naming-convention" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>The naming convention in Haskell is camel case.
Meaning in each identifier (type variable, type or binding) all words composing the name are chained directly, with each new word starting with an upper case letter, except for the first word, who&#8217;s case is determined by the syntax contstraints (upper case for types, lower case for type variables and bindings).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tuple-size" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td>The <a class="reference external" href="https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/src/GHC.Tuple.html#%28%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%2C%29">source file for tuples in GHC</a> defined tuples with up to 62 elements.
Below the last declaration is a large block of perhaps 20 more declarations which is commented out, with a note above saying &#8220;Manuel says: Including one more declaration gives a segmentation fault.&#8221;</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="unused-type-variables" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td><p class="first">It is possible to declare type variables on the left and then <em>not</em> use them on the right.
This is often used to tag types with other types, but this is a topic for later.</p>
<p class="last">There are also a language extensions which let you use type variables which only occur on the right side, however this is a very advanced topic.
For now we may simply assume that this is never necessary.</p>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. Types</a><ul>
<li><a class="reference internal" href="#type-variables">4.1. Type variables</a></li>
<li><a class="reference internal" href="#user-defined-types">4.2. User defined types</a><ul>
<li><a class="reference internal" href="#aliases">4.2.1. Aliases</a></li>
<li><a class="reference internal" href="#algebraic-datatypes">4.2.2. Algebraic datatypes</a></li>
<li><a class="reference internal" href="#newtypes">4.2.3. Newtypes</a></li>
<li><a class="reference internal" href="#using-type-variables">4.2.4. Using type variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-case-construct">4.3. The <code class="docutils literal"><span class="pre">case</span></code> construct</a><ul>
<li><a class="reference internal" href="#different-ways-to-write-a-case-expression">4.3.1. Different ways to write a case expression</a></li>
<li><a class="reference internal" href="#case-match-in-function-definition">4.3.2. Case match in function definition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-types">4.4. Special types</a></li>
<li><a class="reference internal" href="#record-syntax">4.5. Record syntax</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="functions.html" title="previous chapter">3. Functions</a></li>
      <li>Next: <a href="exercises/index.html" title="next chapter">5. Exercises</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/types.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Justus Adam.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/types.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>